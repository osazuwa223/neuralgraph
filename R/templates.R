#' Simulate a scale-free signal graph structure from an input structure
#' 
#' Takes an input graph structure, fits a power law model, and simulates a new
#' graph based on the fit.  This function uses the Barabasi-Albert model to 
#' generate graphs implemented in lucy::power_law_sim, however an alteration is made.  
#' The edges of the input graph are reversed before estimating the power law fit, and the 
#' simulated graph edges are reversed again before it is returned from the function.  
#' This way, the graph is characterized not by preferential attachment of incoming edges, but
#' by preferential attachment of outgoing edges.  Further, vertices with 0 degrees are avoided 
#' by having high degree vertices 'donate' edges to degreeless vertices.
#' @param g an igraph object.  
#' @param p number of desired vertices in the output graph.
#' @return A new graph simulated from a power law based on g.
#' @export 
power_signal_graph <- function(g, p){
  g %>%
    reverse_edges %>%
    power_law_sim(p) %>%
    donate_edges %>%
    simplify %>%
    reverse_edges
}

#' Donate edges to degree-less vertices
#' 
#' Used to add edges to nodes that lack edges in graphs generated by power_signal_graph.  
#' A 'rich get poorer' approach is used, wherein nodes with many incoming edges 'donate'
#' an incoming edge to an edgeless node.
#' @param g an igraph output of lucy::power_law_sim
#' @return the graph rewired such that there are no degreeless vertices
donate_edges <- function(g){
  g <- name_vertices(g)
  singletons <- V(g)[igraph::degree(g) == 0]
  while(length(singletons) > 0){
    singletons <- V(g)[igraph::degree(g) == 0]
    v <- V(g)[as.numeric(singletons)[1]]
    #'donators' are all nodes that have incoming edges
    candidate_donators <- V(g)[igraph::degree(g, mode = "in") > 0]
    # Use power law to get selection probability. The more edges a donator has, the higher
    # its probability of selection.
    power_calc <- igraph::degree(g, mode = "in")[candidate_donators] ^ g$power + g$zero.appeal
    prob <- power_calc / sum(power_calc)
    # Select one of the donators with this probability
    donator <- V(g)[sample(candidate_donators$name, 1, prob = prob)]$name # select a donator
    donated_edge <- E(g)[to(V(g)[donator])] %>% # pick an edge to switch
      as.numeric %>%
      {.[
        lapply(., function(e) get_edge_vertex(g, e, "from")) %>%
    # only chose an edge for donating from nodes that have more than one edge
      lapply(function(v) length((igraph::neighborhood(g, 1, V(g)[v]))[[1]]) >= 2) %>%
      unlist
    ]} %>%
      sample(1) %>%
  {E(g)[.]}
  # Add an edge from source of 
  source_v <- get_edge_vertex(g, donated_edge, "from")
  g <- g + edge(V(g)[source_v]$name, V(g)[v]$name)
  # Remove the chosen edge.
  g <- delete.edges(g, donated_edge)
  g <- simplify(g)
  singletons <- V(g)[igraph::degree(g) == 0]
  }
  g %>%
    ensure_that(is.dag(.)) %>%
    ensure_that(is.simple(.))
}

#' Sim data given a graph
#' 
#' For simulation and testing purposes.
#' Given an igraph object, simulates data on the graph that would 
#' be representative of the data expected when fitting a signal graph in
#' the wild.
#' @param g an igraph object
#' @param n the number of desired observations in the data
#' @return a data frame.
#' @export
sim_data_on_graph <- function(g, n){  
  roots <- V(g)[get_roots(g)]$name 
  leaves <- V(g)[get_leaves(g)]$name
  num_roots_leaves <- length(c(roots, leaves))
  k <- sample(num_roots_leaves:(vcount(g)), 1) # Number of observed nodes
  .data <- c(lapply(roots, function(root) runif(n)), 
             lapply(leaves, function(leaf) runif(n))) %>%
    as.data.frame %>%
    `names<-`(c(roots, leaves))
  if(k > num_roots_leaves){
    observed_middle_nodes <- setdiff(V(g)$name, c(leaves, roots)) %>% 
      sample(k - num_roots_leaves)
    .data <- lapply(observed_middle_nodes, FUN = function(item) runif(n)) %>%
      as.data.frame %>%
      `names<-`(observed_middle_nodes) %>%
      cbind(.data)
  } 
  .data
}


#' Test Case: Random graph and matching data
#' 
#' Generates an igraph object and a corresponding dataset.  A number of unobserved vertices will 
#' be chosen at random.  Used to randomly generate test cases.  If supplied an input graph structure,
#' the new structure is simulated using a power law.  Otherwise, the function uses the sim_DAG in 
#' the lucy \url{https://github.com/robertness/lucy} package.
#' 
#' 
#' @param m the number of desired nodes
#' @param n the number of desired rows in the data
#' @param input_g an igraph object.  If supplied then the graph is simulated from
#' a power law fit on this input graph. 
#' @param method the fitting method for simulating a directed acyclic graph.  Ignored
#' if input_g is supplied. 
#' @return A list of two elements, graph and data.
#' @seealso power_signal_graph
#' @seealso sim_DAG
#' @export
rand_case <- function(m, p = m * m + m, input_g = NULL, method = "ordered"){
  if(is.null(input_g)){
    g <- lucy::sim_DAG(p, method = method)
  } else {
    g <- power_signal_graph(input_g, p)
  }
  g <-  name_vertices(g)
  .data <- sim_data_on_graph(g, n)
  list(g = g, data = .data)
}

#' Generate a random unfit signalgraph object
#'   
#' Since the vertices that must have data are the roots and the leaves, (everything in between can be hidden),
#' then a data frame is simulated for only those nodes.
#' 
#' @param p the number of desired nodes
#' @param n the number of desired rows in the data
#' @param input_g an igraph object.  If supplied then the graph is simulated from
#' a power law fit on this input graph. 
#' @param method the fitting method for simulating a directed acyclic graph.  Ignored
#' if input_g is supplied. 
#' @param no_fixed_prob probability of generating a case with no fixed variable nodes
#' @return an initialized, but unfit (unoptimized) signal graph model
#' @seealso power_signal_graph
#' @seealso sim_DAG
#' @seealso rand_case
#' @export
random_unfit_sg <- function(p, n = p * p + p, input_g = NULL, method = "ordered", no_fixed_prob = .3, ...){
  if(is.null(input_g)){
    case <- rand_case(p, n, method = "method")
  } else {
    case <- rand_case(p, n, input_g = input_g)
  }
  no_fixed <- sample(c(TRUE, FALSE), 1, prob = c(no_fixed_prob, 1 - no_fixed_prob))
  if(no_fixed){
    return(initializeGraph(case$g, case$data, ...))
  }
  roots <- V(case$g)[get_roots(case$g)]$name
  initializeGraph(case$g, case$data, fixed = roots, ...)
}

#' Generate a random fitted signalgraph object
#' 
#' Uses the sim_DAG in the lucy \url{https://github.com/robertness/lucy} package.  
#' The vertices that must have data are the roots and the leaves, (everything in between can be hidden),
#' so data is simulated for only those nodes.
#' 
#' @param m the number of desired nodes
#' @param n the number of desired rows in the data
#' @param ... additional arguments, including graph attributes
#' @param input_g an igraph object.  If supplied then the graph is simulated from
#' a power law fit on this input graph. 
#' @param method the fitting method for simulating a directed acyclic graph.  Ignored
#' if input_g is supplied. 
#' @param no_fixed boolean if TRUE then all vertices are treated as random. Defaults to FALSE
#' @return a signalgraph object
#' @export
random_sg <- function(p, n, max.iter = 1, input_g = NULL, method = "ordered", no_fixed = FALSE,...){
  if(is.null(input_g)){
    case <- rand_case(p, n, method = "method")
  } else {
    case <- rand_case(p, n, input_g = input_g)
  }
  if(no_fixed){
    return(fitNetwork(case$g, case$data, ...))
  }
  roots <- V(case$g)[get_roots(case$g)]$name
  fitNetwork(case$g, case$data, fixed = roots, ...)
}

#' Generate a random signalgraph object for data simulation
#' 
#' Produces a signalgraph objectwhere the values of the observed data and the fitted data are the same.  
#' This is designed to produce a gold standard, which can simulate data, where upon a new model can be 
#' fit on the simulated data, and the parameters of the standard and learned parameters of the new model
#' can be compared.
#' 
#' @param m the number of desired nodes
#' @param n the number of desired rows in the data
#' @param input_g an igraph object.  If supplied then the graph is simulated from
#' a power law fit on this input graph. 
#' @param method the fitting method for simulating a directed acyclic graph.  Ignored
#' if input_g is supplied. 
#' @param error_sd desired standard deviation for Gaussian error of logit(x)
#' @param ... arguments past to fitNetwork, including graph attributes
#' @return a signalgraph object
#' @seealso power_signal_graph
#' @seealso sim_DAG
#' @seealso rand_case
#' @export
sim_system <- function(p, n, input_g = NULL, method = "ordered", error_sd = .2, ...){
  if(is.null(input_g)){
    case <- rand_case(p, n, method = "method")
  } else {
    case <- rand_case(p, n, input_g = input_g)
  }
  case$g %>%
    {initializeGraph(.$g, .$data, fixed = get_roots(.$g), ...)} %>%
    loadCN
  fitted_vals <- get_fitted(g)
  logit <- function(x) log(x / (1+x))
  for(node in names(fitted_vals)){ 
    if(V(g)[node]$is.observed){
      observed_val <- fitted_vals[, node] %>%
        logit %>%
        {1 / (1 + exp(-1 * (. + rnorm(n, sd = error_sd))))}
      V(g)[node]$observed <- list(observed_val)
    } 
  }
  g
}

#' Simulate data from a signal graph
#' 
#' Simulates new data for all the fixed variables and propagates those changes
#' through the rest of the system.
#' @param g a signal graph object
#' @param n desired number of rows in output dataframe
#' @param add_error if true, adds noise to each column in output dataframe using the jitter function.
#' @return a dataframe of data
#' @export
sim_system_data <- function(g, n, add_error = FALSE){
  prediction_graph <- resetUpdateAttributes(g)
  fixed_v <- V(prediction_graph)[is.fixed]
  # First sim new values for the output signal
  prediction_graph$n <- n
  for(v in fixed_v){
    V(prediction_graph)[v]$output.signal <- list(runif(n))
  }
  prediction_graph <- update_signals(prediction_graph) 
  # Pull the values into a data 
  .data <- get_fitted(prediction_graph)
  if(add_error) {
    .data <- lapply(.data, jitter) %>%
      as.data.frame %>%
      `names<-`(names(.data))
  }
  .data
}

#' Create an signal graph model of a multi-layer perceptron logic gate (unfit case).
#' 
#' Creates an signal graph model of a multi-layer perceptron logic gate.  The signal graph weights are not fit.
#' This is used primarily for experiments.
#' 
#' @param outputs character vector describing the desired gates.  Defaults to "all", in which case  
#' (AND, OR, NAND, NOR, XOR, and XNOR) are the outputs.  Otherwise any subset of these will work.
#' @param layers a numeric vector where each element corresponds to a layer, and the value of an element
#' is the number of hidden nodes in the layer.  Default is NULL.  If value is null, no hidden layers will be
#' present (just an input and output layer).
#' @return a signal graph model object with unfit weights
#' 
#' @export
get_gate <- function(outputs = "all", layers=NULL){
  gates <- c("AND", "OR", "NAND", "NOR", "XOR", "XNOR")  
  if(!all(outputs %in% c("all", gates))) stop("Invalid set of gates.")
  logic_gates <- expand.grid(list(I1 = c(0, 1), I2 = c(0, 1))) %>% #Create the logic gate table
    transform(AND = (I1 * I2 == 1) * 1, 
              OR = (I1 + I2 > 0) * 1) %>%
    transform(NAND = (!AND) * 1,
              NOR = (!OR) * 1,
              XOR = (I1 + I2 == 1) * 1, 
              XNOR = (I1 == I2) * 1)
  g <- igraphr::mlp_graph(inputs = c("I1", "I2"),
                    outputs = gates, layers = layers) %>%
    initializeGraph(logic_gates[, c("I1", "I2", gates)], fixed = c("I1", "I2"))
  if(!identical(outputs, "all")){
    output_nodes <- c(V(g)[c("I1", "I2")], V(g)[name %in% outputs])
    exclusion_nodes <- V(g)[is.observed]  %>% setdiff(output_nodes)
    nuisance_biases <- exclusion_nodes %>% # Find the biases for the outputs that will be excluded
      lapply(lucy::iparents, g=g) %>%
      unlist %>%
      intersect(V(g)[is.bias])
    g <- igraph::induced.subgraph(g, setdiff(V(g), c(exclusion_nodes, nuisance_biases)))
  }
  name_edges(g) 
}